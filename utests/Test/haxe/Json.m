//
//  Json
//  Test
//
//  Source generated by Haxe Objective-C target
//

#import "../haxe/Json.h"

@implementation Json

+ (id) parse:(NSMutableString*)text{
	return [[[Json alloc] init] doParse:text];
}
+ (NSMutableString*) stringify:(id)value replacer:(SEL)replacer{
	// Simulated optional arguments
	if (replacer == nil) replacer = nil;
	
	return [[[Json alloc] init] toString:value replacer:replacer];
}
@synthesize buf;
@synthesize str;
@synthesize pos;

- (NSMutableString*) toString:(id)v replacer:(SEL)replacer{
	// Simulated optional arguments
	if (replacer == nil) replacer = nil;
	
	self.buf = [[StringBuf alloc] init];
	self.replacer = replacer;
	[self toStringRec:(NSMutableString*)@"" v:v];
	return self.buf.b;
}
- (void) fieldsString:(id)v fields:(NSMutableArray*)fields{
	BOOL first = YES;
	[self.buf.b appendString:(NSMutableString*)@"{"];
	{
		int _g = 0;
		while (_g < fields.length) {
			
			NSMutableString *f = [fields objectAtIndex:_g];
			++_g;
			id value = [Reflect field:v field:f];
			if ([Reflect isFunction:value]) continue;
			if (first) first = NO;
			else [self.buf.b appendString:(NSMutableString*)@","];
			[self quote:f];
			[self.buf.b appendString:(NSMutableString*)@":"];
			[self toStringRec:f v:value];
		}
	}
	[self.buf.b appendString:(NSMutableString*)@"}"];
}
- (void) objString:(id)v{
	[self fieldsString:v fields:[Reflect fields:v]];
}
- (void) toStringRec:(id)k v:(id)v{
	if (self.replacer != nil) v = [self replacer:k :v];
	{
		
		Type *_g = [Type _typeof:v];
		
		var $e : enum =  (_g)
		switch ( $e.index ) {
			
			case 8:
			{
				[self.buf.b appendString:(NSMutableString*)@"\"???\""]}break
			case 4:
			{
				[self objString:v]}break
			case 1:
			{
				{
					
					NSMutableString *v1 = v;
					self.buf.b += [Std string:v1];
				}}break
			case 2:
			{
				self.buf.b += [Std string:( (isfinite(v)) ? v : (NSMutableString*)@"null")]}break
			case 5:
			{
				[self.buf.b appendString:(NSMutableString*)@"\"<fun>\""]}break
			case 6:
			
			var MATCH _g_eTClass_0 : Class = $e.params[0]{
				if (_g_eTClass_0 == NSMutableString) [self quote:v];
				else if (_g_eTClass_0 == NSMutableArray) {
					
					NSMutableArray *v1 = (NSMutableArray*)v;
					[self.buf.b appendString:(NSMutableString*)@"["];
					int len = v1.length;
					if (len > 0) {
						[self toStringRec:0 v:[v1 objectAtIndex:0]];
						int i = 1;
						while (i < len) {
							[self.buf.b appendString:(NSMutableString*)@","];
							[self toStringRec:i v:[v1 objectAtIndex:i++]];
						}
					}
					[self.buf.b appendString:(NSMutableString*)@"]"];
				}
				else if (_g_eTClass_0 == StringMap) {
					
					StringMap *v1 = v;
					id o = struct {
					
					} structName;
					{
						id _it2 = [v1 keys];
						while ( [_it2 hasNext] ) do {
							NSMutableString k1 = [_it2 next];
							if (o != nil) [o __SetField-TDynamic-];
						}
					}
					[self objString:o];
				}
				else [self objString:v]}break
			case 7:
			{
				{
					id i = ((int)($this:(snd ctx.path)) 
					EnumValue *e = v
					__r__3 = [e __Index]
					return __r__3{
						
						int* __r__3}
					}(self));
					{
						
						NSMutableString *v1 = i;
						self.buf.b += [Std string:v1];
					}
				}}break
			case 3:
			{
				{
					
					NSMutableString *v1 = v;
					self.buf.b += [Std string:v1];
				}}break
			case 0:
			{
				[self.buf.b appendString:(NSMutableString*)@"null"]}break
		}
	}
}
- (void) quote:(NSMutableString*)s{
	[self.buf.b appendString:(NSMutableString*)@"\""];
	int i = 0;
	while (YES) {
		int c = [s characterAtIndex:i++];
		if (c == -1) break;
		switch (c){
			case 34:{
				[self.buf.b appendString:(NSMutableString*)@"\\\""]}break;
			case 92:{
				[self.buf.b appendString:(NSMutableString*)@"\\\\"]}break;
			case 10:{
				[self.buf.b appendString:(NSMutableString*)@"\\n"]}break;
			case 13:{
				[self.buf.b appendString:(NSMutableString*)@"\\r"]}break;
			case 9:{
				[self.buf.b appendString:(NSMutableString*)@"\\t"]}break;
			case 8:{
				[self.buf.b appendString:(NSMutableString*)@"\\b"]}break;
			case 12:{
				[self.buf.b appendString:(NSMutableString*)@"\\f"]}break;
			default:{
				self.buf.b += [NSMutableString fromCharCode:c]}break;
		}
	}
	[self.buf.b appendString:(NSMutableString*)@"\""];
}
- (id) doParse:(NSMutableString*)str{
	self.str = str;
	self.pos = 0;
	return [self parseRec];
}
- (void) invalidChar{
	self.pos--;
	@throw [[[(NSMutableString*)@"Invalid char " stringByAppendingString:[self.str characterAtIndex:self.pos]] stringByAppendingString:(NSMutableString*)@" at position "] stringByAppendingString:self.pos];;
}
- (id) parseRec{
	while (YES) {
		int c = [self.str characterAtIndex:self.pos++];
		switch (c){
			case 32:case 13:case 10:case 9:{
				break;
				case 123:{
					{
						id obj = struct {
						
						} structName; 
						NSMutableString *field = nil; BOOL comma = nil;
						while (YES) {
							int c1 = [self.str characterAtIndex:self.pos++];
							switch (c1){
								case 32:case 13:case 10:case 9:{
									break;
									case 125:{
										{
											if (field != nil || comma == NO) [self invalidChar];
											return obj;
										}}break;
									case 58:{
										{
											if (field == nil) [self invalidChar];
											if (obj != nil) [obj __SetField-TDynamic-];
											field = nil;
											comma = YES;
										}}break;
									case 44:{
										if (comma) comma = NO;
										else [self invalidChar]}break;
									case 34:{
										{
											if (comma) [self invalidChar];
											field = [self parseString];
										}}break;
									default:{
										[self invalidChar]}break;
								}
							}
						}}break;
					case 91:{
						{
							
							NSMutableArray *arr = [[NSMutableArray alloc] initWithObjects:, nil]; BOOL comma = nil;
							while (YES) {
								int c1 = [self.str characterAtIndex:self.pos++];
								switch (c1){
									case 32:case 13:case 10:case 9:{
										break;
										case 93:{
											{
												if (comma == NO) [self invalidChar];
												return arr;
											}}break;
										case 44:{
											if (comma) comma = NO;
											else [self invalidChar]}break;
										default:{
											{
												if (comma) [self invalidChar];
												self.pos--;
												[arr push:[self.parseRec]];
												comma = YES;
											}}break;
									}
								}
							}}break;
						case 116:{
							{
								int save = self.pos;
								if ([self.str characterAtIndex:self.pos++] != 114 || [self str characterAtIndex:self.pos++] != 117 || [self str characterAtIndex:self.pos++] != 101) {
									self.pos = save;
									[self invalidChar];
								}
								return YES;
							}}break;
						case 102:{
							{
								int save = self.pos;
								if ([self.str characterAtIndex:self.pos++] != 97 || [self str characterAtIndex:self.pos++] != 108 || [self str characterAtIndex:self.pos++] != 115 || [self str characterAtIndex:self.pos++] != 101) {
									self.pos = save;
									[self invalidChar];
								}
								return NO;
							}}break;
						case 110:{
							{
								int save = self.pos;
								if ([self.str characterAtIndex:self.pos++] != 117 || [self str characterAtIndex:self.pos++] != 108 || [self str characterAtIndex:self.pos++] != 108) {
									self.pos = save;
									[self invalidChar];
								}
								return nil;
							}}break;
						case 34:{
							return [self parseString]}break;
						case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:case 45:{
							return ((float)($this:(snd ctx.path)) int c1 = c
							int start = self.pos - 1
							BOOL minus = c1 == 45; BOOL digit = !minus; BOOL zero = c1 == 48
							BOOL point = NO; BOOL e = NO; BOOL pm = NO; BOOL end = NO
							while (YES) {
								c1 = [self str characterAtIndex:self.pos++];
								switch (c1){
									case 48:{
										{
											if (zero && !point) [self invalidNumber:start];
											if (minus) {
												minus = NO;
												zero = YES;
											}
											digit = YES;
										}}break;
									case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:{
										{
											if (zero && !point) [self invalidNumber:start];
											if (minus) minus = NO;
											digit = YES;
											zero = NO;
										}}break;
									case 46:{
										{
											if (minus || point) [self invalidNumber:start];
											digit = NO;
											point = YES;
										}}break;
									case 101:case 69:{
										{
											if (minus || zero || e) [self invalidNumber:start];
											digit = NO;
											e = YES;
										}}break;
									case 43:case 45:{
										{
											if (!e || pm) [self invalidNumber:start];
											digit = NO;
											pm = YES;
										}}break;
									default:{
										{
											if (!digit) [self invalidNumber:start];
											self.pos--;
											end = YES;
										}}break;
								}
								if (end) break;
							}
							float f = [Std parseFloat:[self.str substr:start len:self.pos - start]]
							int i = [Std _int:f]
							__r__ = ( (i == f) ? i : f)
							return __r__{
								
								float* __r__}
							}(self))}break;
						default:{
							[self invalidChar]}break;
					}
				}
				return nil;
			}
			- (NSMutableString*) parseString{
				int start = self.pos;
				
				StringBuf *buf = [[StringBuf alloc] init];
				while (YES) {
					int c = [self.str characterAtIndex:self.pos++];
					if (c == 34) break;
					if (c == 92) {
						{
							
							NSMutableString *s = self.str; int len = self.pos - start - 1;
							buf.b += ( (len == nil) ? [s substr:start len:nil] : [s substr:start len:len]);
						}
						c = [self str characterAtIndex:self.pos++];
						switch (c){
							case 114:{
								[buf.b appendString:(NSMutableString*)@"\r"]}break;
							case 110:{
								[buf.b appendString:(NSMutableString*)@"\n"]}break;
							case 116:{
								[buf.b appendString:(NSMutableString*)@"\t"]}break;
							case 98:{
								[buf.b appendString:(NSMutableString*)@""]}break;
							case 102:{
								[buf.b appendString:(NSMutableString*)@""]}break;
							case 47:case 92:case 34:{
								buf.b += [NSMutableString fromCharCode:c]}break;
							case 117:{
								{
									int uc = [Std parseInt:[(NSMutableString*)@"0x" stringByAppendingString:[self.str substr:self.pos len:@"4"]]];
									self.pos += 4;
									buf.b += [NSMutableString fromCharCode:uc];
								}}break;
							default:{
								@throw [[[(NSMutableString*)@"Invalid escape sequence \\" stringByAppendingString:[NSMutableString fromCharCode:c]] stringByAppendingString:(NSMutableString*)@" at position "] stringByAppendingString: (self.pos - @"1")];}break;
						}
						start = self.pos;
					}
					else if (c == -1) @throw (NSMutableString*)@"Unclosed string";;
				}
				{
					
					NSMutableString *s = self.str; int len = self.pos - start - 1;
					buf.b += ( (len == nil) ? [s substr:start len:nil] : [s substr:start len:len]);
				}
				return buf.b;
			}
			- (void) invalidNumber:(int)start{
				@throw [[[(NSMutableString*)@"Invalid number at position " stringByAppendingString:start] stringByAppendingString:(NSMutableString*)@": "] stringByAppendingString:[self.str substr:start len:self.pos - start]];;
			}
			- (id) init{
				self = [super init];
				return self;
			}

@end
