//
//  Sha1
//  Tests
//
//  Source generated by Haxe Objective-C target
//

#import "Sha1.h"

@implementation Sha1

+ (NSMutableString*) encode:(NSMutableString*)s{
	const char *cstr = [input cStringUsingEncoding:NSUTF8StringEncoding];
	NSData *data = [NSData dataWithBytes:cstr length:input.length];
	uint8_t digest[CC_SHA1_DIGEST_LENGTH];
	CC_SHA1(data.bytes, data.length, digest);
	NSMutableString* output = [NSMutableString stringWithCapacity:CC_SHA1_DIGEST_LENGTH * 2];
	for (int i = 0; i < CC_SHA1_DIGEST_LENGTH; i++) [output appendFormat:@"%02x", digest[i]];;
	return output;
}
+ (Bytes*) make:(Bytes*)b{
	
	NSMutableArray *h = (NSMutableArray*)[[[Sha1 alloc] init] doEncode:[Sha1 bytes2blks:b]];
	
	Bytes *_out = [Bytes alloc:20];
	int p = 0;
	{
		int _g = 0;
		while (_g < 5) {
			int i = _g++;
			[_out.b objectAtIndex:p++] = ([h objectAtIndex:i] >>> 24 & 255);
			[_out.b objectAtIndex:p++] = (([h objectAtIndex:i] >> 16 & 255) & 255);
			[_out.b objectAtIndex:p++] = (([h objectAtIndex:i] >> 8 & 255) & 255);
			[_out.b objectAtIndex:p++] = (([h objectAtIndex:i] & 255) & 255);
		}
	}
	return _out;
}
+ (NSMutableArray*) str2blks:(NSMutableString*)s{
	int nblk =  (s.length + 8 >> 6) + 1;
	
	NSMutableArray *blks = (NSMutableArray*)[[NSMutableArray alloc] init];
	{
		int _g1 = 0; int _g = nblk * 16;
		while (_g1 < _g) {
			int i = _g1++;
			[blks objectAtIndex:i] = 0;
		}
	}
	{
		int _g1 = 0; int _g = s.length;
		while (_g1 < _g) {
			int i = _g1++;
			int p = i >> 2;
			[blks objectAtIndex:p] |= [s characterAtIndex:i] << 24 -  ( (i & 3) << 3);
		}
	}
	int i = s.length;
	int p = i >> 2;
	[blks objectAtIndex:p] |= 128 << 24 -  ( (i & 3) << 3);
	[blks objectAtIndex:nblk * 16 - 1] = s.length * 8;
	return blks;
}
+ (NSMutableArray*) bytes2blks:(Bytes*)b{
	int nblk =  (b.length + 8 >> 6) + 1;
	
	NSMutableArray *blks = (NSMutableArray*)[[NSMutableArray alloc] init];
	{
		int _g1 = 0; int _g = nblk * 16;
		while (_g1 < _g) {
			int i = _g1++;
			[blks objectAtIndex:i] = 0;
		}
	}
	{
		int _g1 = 0; int _g = b.length;
		while (_g1 < _g) {
			int i = _g1++;
			int p = i >> 2;
			[blks objectAtIndex:p] |= [b.b objectAtIndex:i] << 24 -  ( (i & 3) << 3);
		}
	}
	int i = b.length;
	int p = i >> 2;
	[blks objectAtIndex:p] |= 128 << 24 -  ( (i & 3) << 3);
	[blks objectAtIndex:nblk * 16 - 1] = b.length * 8;
	return blks;
}
- (NSMutableArray*) doEncode:(NSMutableArray*)x{
	
	NSMutableArray *w = (NSMutableArray*)[[NSMutableArray alloc] init];
	int a = 1732584193;
	int b = -271733879;
	int c = -1732584194;
	int d = 271733878;
	int e = -1009589776;
	int i = 0;
	while (i < x.length) {
		int olda = a;
		int oldb = b;
		int oldc = c;
		int oldd = d;
		int olde = e;
		int j = 0;
		while (j < 80) {
			if (j < 16) [w objectAtIndex:j] = [x objectAtIndex:i + j];
			else [w objectAtIndex:j] = ((int)($this:(snd ctx.path)) int num = (([w objectAtIndex:j - 3] ^ [w objectAtIndex:j - 8]) ^ [w objectAtIndex:j - 14]) ^ [w objectAtIndex:j - 16]
			__r__ = (num << 1 | num >>> 31)
			return __r__{
				
				int* __r__}
			}(self));
			int t =  (a << 5 | a >>> 27) + [self ft:j b:b c:c d:d] + e + [w objectAtIndex:j] + [self kt:j];
			e = d;
			d = c;
			c = (b << 30 | b >>> 2);
			b = a;
			a = t;
			j++;
		}
		a += olda;
		b += oldb;
		c += oldc;
		d += oldd;
		e += olde;
		i += 16;
	}
	return [[NSMutableArray alloc] initWithObjects:a, b, c, d, e, nil];
}
- (int) rol:(int)num cnt:(int)cnt{
	return num << cnt | num >>> 32 - cnt;
}
- (int) ft:(int)t b:(int)b c:(int)c d:(int)d{
	if (t < 20) return (b & c) | (~b & d);
	if (t < 40) return (b ^ c) ^ d;
	if (t < 60) return ((b & c) | (b & d)) | (c & d);
	return (b ^ c) ^ d;
}
- (int) kt:(int)t{
	if (t < 20) return 1518500249;
	if (t < 40) return 1859775393;
	if (t < 60) return -1894007588;
	return -899497514;
}
- (NSMutableString*) hex:(NSMutableArray*)a{
	
	NSMutableString *str = (NSMutableString*)@"";
	
	NSMutableString *hex_chr = (NSMutableString*)@"0123456789abcdef";
	{
		int _g = 0;
		while (_g < a.length) {
			int num = [a objectAtIndex:_g];
			++_g;
			int j = 7;
			while (j >= 0) {
				[str appendString:[hex_chr characterAtIndex:num >>>  (j << @"2") & @"15"]];
				j--;
			}
		}
	}
	return str;
}
- (id) init{
	self = [super init];
	return self;
}

@end
