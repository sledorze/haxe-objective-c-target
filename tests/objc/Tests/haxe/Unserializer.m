//
//  Unserializer
//  Tests
//
//  Source generated by Haxe Objective-C target
//

#import "../haxe/Unserializer.h"

@implementation Unserializer

+ (id) DEFAULT_RESOLVER:(id)val {
	static id _val;
	if (val == nil) { if (_val == nil) _val = Type; }
	else { if (_val != nil) _val = val; }
	return _val;
}
+ (NSMutableString*) BASE64:(NSMutableString*)val {
	static NSMutableString *_val;
	if (val == nil) { if (_val == nil) _val = (NSMutableString*)@"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"; }
	else { if (_val != nil) _val = val; }
	return _val;
}
+ (NSMutableArray*) CODES:(NSMutableArray*)val {
	static NSMutableArray *_val;
	if (val == nil) { if (_val == nil) _val = nil; }
	else { if (_val != nil) _val = val; }
	return _val;
}
+ (NSMutableArray*) initCodes{
	
	NSMutableArray *codes = (NSMutableArray*)[[NSMutableArray alloc] init];
	{
		int _g1 = 0; int _g = Unserializer.BASE64.length;
		while (_g1 < _g) {
			int i = _g1++;
			[codes objectAtIndex:[Unserializer.BASE64 characterAtIndex:i]] = i;
		}
	}
	return codes;
}
+ (id) run:(NSMutableString*)v{
	return [[[Unserializer alloc] init:v] unserialize];
}
@synthesize buf;
@synthesize pos;
@synthesize length;
@synthesize cache;
@synthesize scache;
@synthesize resolver;
- (void) setResolver:(id)r{
	if (r == nil) self.resolver = struct {
	resolveClass:^- (Class*) :(NSMutableString*)_{
		return nil;
	}; resolveEnum:^- (Enum*) :(NSMutableString*)_{
		return nil;
	}
	} structName;
	else self.resolver = r;
}
- (id) getResolver{
	return self.resolver;
}
- (int) get:(int)p{
	return [self.buf characterAtIndex:p];
}
- (int) readDigits{
	int k = 0;
	BOOL s = NO;
	int fpos = self.pos;
	while (YES) {
		int c = [self.buf characterAtIndex:self.pos];
		if (c == -1) break;
		if (c == 45) {
			if (self.pos != fpos) break;
			s = YES;
			self.pos++;
			continue;
		}
		if (c < 48 || c > 57) break;
		k = k * 10 +  (c - 48);
		self.pos++;
	}
	if (s) k *= -1;
	return k;
}
- (void) unserializeObject:(id)o{
	while (YES) {
		if (self.pos >= self.length) @throw (NSMutableString*)@"Invalid object";;
		if ([self.buf characterAtIndex:self.pos] == 103) break;
		
		NSMutableString *k = [self unserialize];
		if (![Std is:k t:NSMutableString]) @throw (NSMutableString*)@"Invalid object key";;
		id v = [self unserialize];
		if (o != nil) [o __SetField-TDynamic-];
	}
	self.pos++;
}
- (id) unserializeEnum:(Enum*)edecl tag:(NSMutableString*)tag{
	if ([self.buf characterAtIndex:self.pos++] != 58) @throw (NSMutableString*)@"Invalid enum format";;
	int nargs = [self readDigits];
	if (nargs == 0) return [Type createEnum:edecl constr:tag params:nil];
	
	NSMutableArray *args = (NSMutableArray*)[[NSMutableArray alloc] init];
	while (nargs-- > 0) [args push:[self.unserialize]];
	return [Type createEnum:edecl constr:tag params:args];
}
- (id) unserialize{
	{
		int _g = [self.buf characterAtIndex:self.pos++];
		switch (_g){
			case 110:{
				return nil}break;
			case 116:{
				return YES}break;
			case 102:{
				return NO}break;
			case 122:{
				return 0}break;
			case 105:{
				return [self readDigits]}break;
			case 100:{
				{
					int p1 = self.pos;
					while (YES) {
						int c = [self.buf characterAtIndex:self.pos];
						if (c >= 43 && c < 58 || c == 101 || c == 69) self.pos++;
						else break;
					}
					return [Std parseFloat:[self.buf substr:p1 len:self.pos - p1]];
				}}break;
			case 121:{
				{
					int len = [self readDigits];
					if ([self.buf characterAtIndex:self.pos++] != 58 || self.length - self.pos < len) @throw (NSMutableString*)@"Invalid string length";;
					
					NSMutableString *s = [self.buf substr:self.pos len:len];
					self.pos += len;
					s = [StringTools urlDecode:s];
					[self.scache push:s];
					return s;
				}}break;
			case 107:{
				return MathNAN}break;
			case 109:{
				return Math-DBL_MAX}break;
			case 112:{
				return MathDBL_MAX}break;
			case 97:{
				{
					
					NSMutableString *buf = self.buf;
					
					NSMutableArray *a = (NSMutableArray*)[[NSMutableArray alloc] init];
					[self.cache push:a];
					while (YES) {
						int c = [self.buf characterAtIndex:self.pos];
						if (c == 104) {
							self.pos++;
							break;
						}
						if (c == 117) {
							self.pos++;
							int n = [self readDigits];
							[a objectAtIndex:a.length + n - 1] = nil;
						}
						else [a push:[self.unserialize]];
					}
					return a;
				}}break;
			case 111:{
				{
					id o = struct {
					
					} structName;
					[self.cache push:o];
					[self unserializeObject:o];
					return o;
				}}break;
			case 114:{
				{
					int n = [self readDigits];
					if (n < 0 || n >= self.cache.length) @throw (NSMutableString*)@"Invalid reference";;
					return [self.cache objectAtIndex:n];
				}}break;
			case 82:{
				{
					int n = [self readDigits];
					if (n < 0 || n >= self.scache.length) @throw (NSMutableString*)@"Invalid string reference";;
					return [self.scache objectAtIndex:n];
				}}break;
			case 120:{
				@throw [self unserialize];}break;
			case 99:{
				{
					
					NSMutableString *name = [self unserialize];
					
					Class *cl = [self.resolver resolveClass:name];
					if (cl == nil) @throw [(NSMutableString*)@"Class not found " stringByAppendingString:name];;
					id o = [Type createEmptyInstance:cl];
					[self.cache push:o];
					[self unserializeObject:o];
					return o;
				}}break;
			case 119:{
				{
					
					NSMutableString *name = [self unserialize];
					
					Enum *edecl = [self.resolver resolveEnum:name];
					if (edecl == nil) @throw [(NSMutableString*)@"Enum not found " stringByAppendingString:name];;
					id e = [self unserializeEnum:edecl tag:[self.unserialize]];
					[self.cache push:e];
					return e;
				}}break;
			case 106:{
				{
					
					NSMutableString *name = [self unserialize];
					
					Enum *edecl = [self.resolver resolveEnum:name];
					if (edecl == nil) @throw [(NSMutableString*)@"Enum not found " stringByAppendingString:name];;
					self.pos++;
					int index = [self readDigits];
					
					NSMutableString *tag = [[Type getEnumConstructs:edecl] objectAtIndex:index];
					if (tag == nil) @throw [[[(NSMutableString*)@"Unknown enum index " stringByAppendingString:name] stringByAppendingString:(NSMutableString*)@"@"] stringByAppendingString:index];;
					id e = [self unserializeEnum:edecl tag:tag];
					[self.cache push:e];
					return e;
				}}break;
			case 108:{
				{
					
					List *l = [[List alloc] init];
					[self.cache push:l];
					
					NSMutableString *buf = self.buf;
					while ([self.buf characterAtIndex:self.pos] != 104) [l add:[self.unserialize]];
					self.pos++;
					return l;
				}}break;
			case 98:{
				{
					
					StringMap *h = [[StringMap alloc] init];
					[self.cache push:h];
					
					NSMutableString *buf = self.buf;
					while ([self.buf characterAtIndex:self.pos] != 104) {
						
						NSMutableString *s = [self unserialize];
						[h set:s value:[self.unserialize]];
					}
					self.pos++;
					return h;
				}}break;
			case 113:{
				{
					
					IntMap *h = [[IntMap alloc] init];
					[self.cache push:h];
					
					NSMutableString *buf = self.buf;
					int c = [self.buf characterAtIndex:self.pos++];
					while (c == 58) {
						int i = [self readDigits];
						[h set:i value:[self.unserialize]];
						c = [self buf characterAtIndex:self.pos++];
					}
					if (c != 104) @throw (NSMutableString*)@"Invalid IntMap format";;
					return h;
				}}break;
			case 77:{
				{
					
					ObjectMap *h = [[ObjectMap alloc] init:nil];
					[self.cache push:h];
					
					NSMutableString *buf = self.buf;
					while ([self.buf characterAtIndex:self.pos] != 104) {
						id s = [self unserialize];
						[h set:s value:[self.unserialize]];
					}
					self.pos++;
					return h;
				}}break;
			case 118:{
				{
					
					NSDate *d = [NSDate fromString:[self.buf substr:self.pos len:19]];
					[self.cache push:d];
					self.pos += 19;
					return d;
				}}break;
			case 115:{
				{
					int len = [self readDigits];
					
					NSMutableString *buf = self.buf;
					if ([self.buf characterAtIndex:self.pos++] != 58 || self.length - self.pos < len) @throw (NSMutableString*)@"Invalid bytes length";;
					
					NSMutableArray *codes = (NSMutableArray*)Unserializer.CODES;
					if (codes == nil) {
						codes = [Unserializer initCodes];
						Unserializer.CODES = codes;
					}
					int i = self.pos;
					int rest = len & 3;
					int size =  (len >> 2) * 3 +  (( (rest >= 2) ? rest - 1 : 0));
					int max = i +  (len - rest);
					
					Bytes *bytes = [Bytes alloc:size];
					int bpos = 0;
					while (i < max) {
						int c1 = [codes objectAtIndex:[buf characterAtIndex:i++]];
						int c2 = [codes objectAtIndex:[buf characterAtIndex:i++]];
						[bytes.b objectAtIndex:bpos++] = ( (c1 << 2 | c2 >> 4) & 255);
						int c3 = [codes objectAtIndex:[buf characterAtIndex:i++]];
						[bytes.b objectAtIndex:bpos++] = ( (c2 << 4 | c3 >> 2) & 255);
						int c4 = [codes objectAtIndex:[buf characterAtIndex:i++]];
						[bytes.b objectAtIndex:bpos++] = ( (c3 << 6 | c4) & 255);
					}
					if (rest >= 2) {
						int c1 = [codes objectAtIndex:[buf characterAtIndex:i++]];
						int c2 = [codes objectAtIndex:[buf characterAtIndex:i++]];
						[bytes.b objectAtIndex:bpos++] = ( (c1 << 2 | c2 >> 4) & 255);
						if (rest == 3) {
							int c3 = [codes objectAtIndex:[buf characterAtIndex:i++]];
							[bytes.b objectAtIndex:bpos++] = ( (c2 << 4 | c3 >> 2) & 255);
						}
					}
					self.pos += len;
					[self.cache push:bytes];
					return bytes;
				}}break;
			case 67:{
				{
					
					NSMutableString *name = [self unserialize];
					
					Class *cl = [self.resolver resolveClass:name];
					if (cl == nil) @throw [(NSMutableString*)@"Class not found " stringByAppendingString:name];;
					id o = [Type createEmptyInstance:cl];
					[self.cache push:o];
					[o hxUnserialize-TDynamic-];
					if ([self.buf characterAtIndex:self.pos++] != 103) @throw (NSMutableString*)@"Invalid custom data";;
					return o;
				}}break;
			default:{
				break;
			}
		}
		self.pos--;
		@throw [[[(NSMutableString*)@"Invalid char " stringByAppendingString:[self.buf characterAtIndex:self.pos]] stringByAppendingString:(NSMutableString*)@" at position "] stringByAppendingString:self.pos];;
		return nil;
	}
	- (id) init:(NSMutableString*)buf{
		self = [super init];
		self.buf = buf;
		self.length = buf.length;
		self.pos = 0;
		self.scache = [[NSMutableArray alloc] init];
		self.cache = [[NSMutableArray alloc] init];
		id r = Unserializer.DEFAULT_RESOLVER;
		if (r == nil) {
			self = [super init];
			r = Type;
			Unserializer.DEFAULT_RESOLVER = r;
			return self;
		}
		[self setResolver:r];
	}

@end
